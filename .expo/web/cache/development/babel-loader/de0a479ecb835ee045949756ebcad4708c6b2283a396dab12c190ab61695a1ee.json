{"ast":null,"code":"'use strict';\n\nvar utils = require(\"./../utils\");\nvar transformData = require(\"./transformData\");\nmodule.exports = function dispatchRequest(config) {\n  config.headers = config.headers || {};\n  config.data = transformData(config.data, config.headers, config.transformRequest);\n  config.headers = utils.merge(config.headers.common || {}, config.headers[config.method] || {}, config.headers || {});\n  utils.forEach(['delete', 'get', 'head', 'post', 'put', 'patch', 'common'], function cleanHeaderConfig(method) {\n    delete config.headers[method];\n  });\n  var adapter;\n  if (typeof config.adapter === 'function') {\n    adapter = config.adapter;\n  } else if (typeof fetch !== 'undefined' && Object.prototype.toString.call(fetch) === '[object Function]') {\n    adapter = require(\"../adapters/fetch\");\n  } else if (typeof XMLHttpRequest !== 'undefined') {\n    adapter = require(\"../adapters/xhr\");\n  } else if (typeof process !== 'undefined') {\n    adapter = require(\"../adapters/http\");\n  }\n  return Promise.resolve(config).then(adapter).then(function onFulfilled(response) {\n    response.data = transformData(response.data, response.headers, config.transformResponse);\n    return response;\n  }, function onRejected(error) {\n    if (error && error.response) {\n      error.response.data = transformData(error.response.data, error.response.headers, config.transformResponse);\n    }\n    return Promise.reject(error);\n  });\n};","map":{"version":3,"names":["utils","require","transformData","module","exports","dispatchRequest","config","headers","data","transformRequest","merge","common","method","forEach","cleanHeaderConfig","adapter","fetch","Object","prototype","toString","call","XMLHttpRequest","process","Promise","resolve","then","onFulfilled","response","transformResponse","onRejected","error","reject"],"sources":["/Users/hemanth/Desktop/Learn/Countrytest/CountryFind/node_modules/react-native-axios/lib/core/dispatchRequest.js"],"sourcesContent":["'use strict';\n\nvar utils = require('./../utils');\nvar transformData = require('./transformData');\n\n/**\n * Dispatch a request to the server using whichever adapter\n * is supported by the current environment.\n *\n * @param {object} config The config that is to be used for the request\n * @returns {Promise} The Promise to be fulfilled\n */\nmodule.exports = function dispatchRequest(config) {\n  // Ensure headers exist\n  config.headers = config.headers || {};\n\n  // Transform request data\n  config.data = transformData(\n    config.data,\n    config.headers,\n    config.transformRequest\n  );\n\n  // Flatten headers\n  config.headers = utils.merge(\n    config.headers.common || {},\n    config.headers[config.method] || {},\n    config.headers || {}\n  );\n\n  utils.forEach(\n    ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],\n    function cleanHeaderConfig(method) {\n      delete config.headers[method];\n    }\n  );\n\n  var adapter;\n\n  if (typeof config.adapter === 'function') {\n    // For custom adapter support\n    adapter = config.adapter;\n  } else if (typeof fetch !== 'undefined' && Object.prototype.toString.call(fetch) === '[object Function]') {\n    // Use new Fetch API\n    adapter = require('../adapters/fetch');\n  } else if (typeof XMLHttpRequest !== 'undefined') {\n    // For browsers use XHR adapter\n    adapter = require('../adapters/xhr');\n  } else if (typeof process !== 'undefined') {\n    // For node use HTTP adapter\n    adapter = require('../adapters/http');\n  }\n\n  return Promise.resolve(config)\n    // Wrap synchronous adapter errors and pass configuration\n    .then(adapter)\n    .then(function onFulfilled(response) {\n      // Transform response data\n      response.data = transformData(\n        response.data,\n        response.headers,\n        config.transformResponse\n      );\n\n      return response;\n    }, function onRejected(error) {\n      // Transform response data\n      if (error && error.response) {\n        error.response.data = transformData(\n          error.response.data,\n          error.response.headers,\n          config.transformResponse\n        );\n      }\n\n      return Promise.reject(error);\n    });\n};\n"],"mappings":"AAAA,YAAY;;AAEZ,IAAIA,KAAK,GAAGC,OAAO,aAAa,CAAC;AACjC,IAAIC,aAAa,GAAGD,OAAO,kBAAkB,CAAC;AAS9CE,MAAM,CAACC,OAAO,GAAG,SAASC,eAAeA,CAACC,MAAM,EAAE;EAEhDA,MAAM,CAACC,OAAO,GAAGD,MAAM,CAACC,OAAO,IAAI,CAAC,CAAC;EAGrCD,MAAM,CAACE,IAAI,GAAGN,aAAa,CACzBI,MAAM,CAACE,IAAI,EACXF,MAAM,CAACC,OAAO,EACdD,MAAM,CAACG,gBACT,CAAC;EAGDH,MAAM,CAACC,OAAO,GAAGP,KAAK,CAACU,KAAK,CAC1BJ,MAAM,CAACC,OAAO,CAACI,MAAM,IAAI,CAAC,CAAC,EAC3BL,MAAM,CAACC,OAAO,CAACD,MAAM,CAACM,MAAM,CAAC,IAAI,CAAC,CAAC,EACnCN,MAAM,CAACC,OAAO,IAAI,CAAC,CACrB,CAAC;EAEDP,KAAK,CAACa,OAAO,CACX,CAAC,QAAQ,EAAE,KAAK,EAAE,MAAM,EAAE,MAAM,EAAE,KAAK,EAAE,OAAO,EAAE,QAAQ,CAAC,EAC3D,SAASC,iBAAiBA,CAACF,MAAM,EAAE;IACjC,OAAON,MAAM,CAACC,OAAO,CAACK,MAAM,CAAC;EAC/B,CACF,CAAC;EAED,IAAIG,OAAO;EAEX,IAAI,OAAOT,MAAM,CAACS,OAAO,KAAK,UAAU,EAAE;IAExCA,OAAO,GAAGT,MAAM,CAACS,OAAO;EAC1B,CAAC,MAAM,IAAI,OAAOC,KAAK,KAAK,WAAW,IAAIC,MAAM,CAACC,SAAS,CAACC,QAAQ,CAACC,IAAI,CAACJ,KAAK,CAAC,KAAK,mBAAmB,EAAE;IAExGD,OAAO,GAAGd,OAAO,oBAAoB,CAAC;EACxC,CAAC,MAAM,IAAI,OAAOoB,cAAc,KAAK,WAAW,EAAE;IAEhDN,OAAO,GAAGd,OAAO,kBAAkB,CAAC;EACtC,CAAC,MAAM,IAAI,OAAOqB,OAAO,KAAK,WAAW,EAAE;IAEzCP,OAAO,GAAGd,OAAO,mBAAmB,CAAC;EACvC;EAEA,OAAOsB,OAAO,CAACC,OAAO,CAAClB,MAAM,CAAC,CAE3BmB,IAAI,CAACV,OAAO,CAAC,CACbU,IAAI,CAAC,SAASC,WAAWA,CAACC,QAAQ,EAAE;IAEnCA,QAAQ,CAACnB,IAAI,GAAGN,aAAa,CAC3ByB,QAAQ,CAACnB,IAAI,EACbmB,QAAQ,CAACpB,OAAO,EAChBD,MAAM,CAACsB,iBACT,CAAC;IAED,OAAOD,QAAQ;EACjB,CAAC,EAAE,SAASE,UAAUA,CAACC,KAAK,EAAE;IAE5B,IAAIA,KAAK,IAAIA,KAAK,CAACH,QAAQ,EAAE;MAC3BG,KAAK,CAACH,QAAQ,CAACnB,IAAI,GAAGN,aAAa,CACjC4B,KAAK,CAACH,QAAQ,CAACnB,IAAI,EACnBsB,KAAK,CAACH,QAAQ,CAACpB,OAAO,EACtBD,MAAM,CAACsB,iBACT,CAAC;IACH;IAEA,OAAOL,OAAO,CAACQ,MAAM,CAACD,KAAK,CAAC;EAC9B,CAAC,CAAC;AACN,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}